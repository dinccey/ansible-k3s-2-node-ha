---
- name: Add helm repos for kite and bitnami
  shell: |
    # Resolve helm binary (prefer system PATH, fall back to /usr/local/bin/helm)
    HELM=$(command -v helm >/dev/null 2>&1 && command -v helm || echo /usr/local/bin/helm)
    $HELM repo add kite {{ kite_helm_repo }} || true
    $HELM repo add bitnami {{ bitnami_helm_repo }} || true
    $HELM repo update
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  register: helm_repos
  changed_when: false
  run_once: true
  delegate_to: "{{ groups['k3s-nodes'][0] }}"

- name: Render postgres values file
  template:
    src: postgres-values.yaml.j2
    dest: /tmp/postgres-values.yaml
    owner: root
    group: root
    mode: '0644'

- name: Install PostgreSQL for Kite if not present
  shell: |
    HELM=$(command -v helm >/dev/null 2>&1 && command -v helm || echo /usr/local/bin/helm)
    if ! $HELM -n {{ postgres_namespace }} status {{ postgres_release_name }} >/dev/null 2>&1; then
      $HELM install {{ postgres_release_name }} {{ postgres_chart }} \
        --namespace {{ postgres_namespace }} \
        --create-namespace \
        --values /tmp/postgres-values.yaml
    fi
  register: postgres_install
  failed_when: postgres_install.rc != 0
  changed_when: postgres_install.rc == 0 and (postgres_install.stdout is defined and postgres_install.stdout != '')
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  become: true
  when: psql_master | default(false)
  run_once: true
  delegate_to: "{{ groups['k3s-nodes'][0] }}"

- name: Wait for postgres primary statefulset rollout (best-effort)
  shell: |
    kubectl -n {{ postgres_namespace }} rollout status statefulset/{{ postgres_release_name }}-postgresql --timeout=300s || true
  register: postgres_rollout
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  become: true

- name: Extract Kite DB password from secret
  shell: |
    kubectl -n {{ postgres_namespace }} get secret {{ postgres_release_name }}-postgresql -o jsonpath="{.data.password}" | base64 -d
  register: kite_db_password
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  failed_when: kite_db_password.rc != 0
  become: true

- name: Set DSN fact for Kite
  set_fact:
    kite_db_dsn: "postgres://{{ postgres_username }}:{{ kite_db_password.stdout }}@{{ postgres_release_name }}-postgresql.{{ postgres_namespace }}.svc.cluster.local:5432/{{ postgres_database }}"

- name: Render kite values file
  template:
    src: kite-values.yaml.j2
    dest: /tmp/kite-values.yaml
    owner: root
    group: root
    mode: '0644'
  vars:
    kite_db_dsn: "{{ kite_db_dsn }}"

- name: Ensure Kite secret exists (so chart doesn't fallback to sqlite)
  shell: |
    kubectl -n {{ kite_namespace }} create namespace {{ kite_namespace }} --dry-run=client -o yaml | kubectl apply -f -
    kubectl -n {{ kite_namespace }} create secret generic {{ kite_release_name }}-secret \
      --from-literal=DB_TYPE=postgres \
      --from-literal=DB_DSN='{{ kite_db_dsn }}' \
      --dry-run=client -o yaml | kubectl apply -f -
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  become: true

- name: Ensure existing kite secret has Helm ownership metadata (labels/annotations)
  shell: |
    if kubectl -n {{ kite_namespace }} get secret {{ kite_release_name }}-secret >/dev/null 2>&1; then
      kubectl -n {{ kite_namespace }} label secret {{ kite_release_name }}-secret app.kubernetes.io/managed-by=Helm --overwrite || true
      kubectl -n {{ kite_namespace }} annotate secret {{ kite_release_name }}-secret meta.helm.sh/release-name={{ kite_release_name }} --overwrite || true
      kubectl -n {{ kite_namespace }} annotate secret {{ kite_release_name }}-secret meta.helm.sh/release-namespace={{ kite_namespace }} --overwrite || true
    fi
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  become: true

- name: Install or upgrade Kite via Helm
  shell: |
    HELM=$(command -v helm >/dev/null 2>&1 && command -v helm || echo /usr/local/bin/helm)
    # Increase timeout to allow resources (PVCs, volumes, init containers) to become ready
    $HELM upgrade --install {{ kite_release_name }} {{ kite_chart }} \
      --namespace {{ kite_namespace }} \
      --create-namespace \
      --values /tmp/kite-values.yaml \
      --atomic --wait --timeout 900s
  register: kite_install
  failed_when: kite_install.rc != 0
  changed_when: kite_install.rc == 0 and (kite_install.stdout is defined and kite_install.stdout != '')
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  become: true
  run_once: true
  delegate_to: "{{ groups['k3s-nodes'][0] }}"

- name: Render Kite Ingress manifest
  template:
    src: kite-ingress.yaml.j2
    dest: /tmp/kite-ingress.yaml
    owner: root
    group: root
    mode: '0644'
  vars:
    kite_host: "{{ kite_domain }}"

- name: Apply Kite Ingress
  command: /usr/local/bin/k3s kubectl apply -f /tmp/kite-ingress.yaml
  register: kite_ingress_apply
  retries: 3
  delay: 5
  until: kite_ingress_apply.rc == 0
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  become: true

- name: Debug- check deployed DB_TYPE in Kite deployment
  shell: |
    kubectl -n {{ kite_namespace }} get deploy {{ kite_release_name }} -o jsonpath="{.spec.template.spec.containers[0].env[?(@.name=='DB_TYPE')].value}"
  register: kite_deployed_db_type
  failed_when: false
  changed_when: false
  run_once: true
  delegate_to: "{{ groups['k3s-nodes'][0] }}"
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  become: true

- name: If deployment still uses sqlite, dump kite-secret and fail with guidance
  block:
    - name: Get kite secret DB_TYPE
      shell: >-
        kubectl -n {{ kite_namespace }} get secret {{ kite_release_name }}-secret \
          -o go-template='{% raw %}{{ index .data "DB_TYPE" }}{% endraw %}' | base64 -d
      register: kite_secret_db_type
      failed_when: false
      changed_when: false
      run_once: true
      delegate_to: "{{ groups['k3s-nodes'][0] }}"
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      become: true

    - name: Get kite secret DB_DSN
      shell: >-
        kubectl -n {{ kite_namespace }} get secret {{ kite_release_name }}-secret \
          -o go-template='{% raw %}{{ index .data "DB_DSN" }}{% endraw %}' | base64 -d
      register: kite_secret_db_dsn
      failed_when: false
      changed_when: false
      run_once: true
      delegate_to: "{{ groups['k3s-nodes'][0] }}"
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      become: true

    - name: Fail and show diagnostics
      fail:
        msg: |
          Kite deployment still shows DB_TYPE={{ kite_deployed_db_type.stdout | default('<none>') }}.
          kite-secret contains DB_TYPE={{ kite_secret_db_type.stdout | default('<none>') }} and DB_DSN={{ kite_secret_db_dsn.stdout | default('<none>') }}.
          Possible causes:
            - Chart sets DB env vars from values that we didn't override. Run `helm show values {{ kite_chart }}` and check the DB keys.
            - Chart templates hardcode sqlite in the Deployment; you'll need to set the chart's DB config keys explicitly.
          I can (A) run `helm show values` and try to auto-detect the correct key, or (B) convert secret/values handling to use the `k8s` module for stronger guarantees.
      when: kite_deployed_db_type.stdout == 'sqlite'
  when: kite_deployed_db_type is defined
